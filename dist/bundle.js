/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/asyncUpdateQueue.ts":
/*!*********************************!*\
  !*** ./src/asyncUpdateQueue.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.queueWatcher = void 0;\r\n// 存储本次更新的所有 watcher\r\nconst queue = [];\r\n// 标识现在是否正在刷新 watcher 队列\r\nlet flushing = false;\r\n// 标识，保证 callbacks 数组中只会有一个刷新 watcher 队列的函数\r\nlet waiting = false;\r\n// 存放刷新 watcher 队列的函数，或者用户调用 Vue.nextTick 方法传递的回调函数\r\nconst callbacks = [];\r\n// 标识浏览器当前任务队列中是否存在刷新 callbacks 数组的函数\r\nlet pending = false;\r\n/**\r\n * 将 watcher 放入队列\r\n * @param {*} watcher 待会儿需要被执行的 watcher，包括渲染 watcher、用户 watcher、computed\r\n */\r\nfunction queueWatcher(watcher) {\r\n    if (!queue.includes(watcher)) { // 防止重复入队\r\n        if (!flushing) { // 现在没有在刷新 watcher 队列\r\n            queue.push(watcher);\r\n        }\r\n        else { // 正在刷新 watcher 队列，比如用户 watcher 的回调函数中更改了某个响应式数据\r\n            // 标记当前 watcher 在 for 中是否已经完成入队操作\r\n            let flag = false;\r\n            // 这时的 watcher 队列时有序的(uid 由小到大)，需要保证当前 watcher 插入进去后仍然有序\r\n            for (let i = queue.length - 1; i >= 0; i--) {\r\n                if (queue[i].uid < watcher.uid) { // 找到了刚好比当前 watcher.uid 小的那个 watcher 的位置\r\n                    // 将当前 watcher 插入到该位置的后面\r\n                    queue.splice(i + 1, 0, watcher);\r\n                    flag = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!flag) { // 说明上面的 for 循环在队列中没找到比当前 watcher.uid 小的 watcher\r\n                // 将当前 watcher 插入到队首 \r\n                queue.unshift(watcher);\r\n            }\r\n        }\r\n        if (!waiting) { // 表示当前 callbacks 数组中还没有刷新 watcher 队列的函数\r\n            // 保证 callbacks 数组中只会有一个刷新 watcher 队列的函数\r\n            // 因为如果有多个，没有任何意义，第二个执行的时候 watcher 队列已经为空了\r\n            waiting = true;\r\n            nextTick(flushSchedulerQueue);\r\n        }\r\n    }\r\n}\r\nexports.queueWatcher = queueWatcher;\r\n/**\r\n * 负责刷新 watcher 队列的函数，由 flushCallbacks 函数调用\r\n */\r\nfunction flushSchedulerQueue() {\r\n    // 表示正在刷新 watcher 队列\r\n    flushing = true;\r\n    // 给 watcher 队列排序，根据 uid 由小到大排序\r\n    queue.sort((a, b) => a.uid - b.uid);\r\n    // 遍历队列，依次执行其中每个 watcher 的 run 方法\r\n    while (queue.length) {\r\n        // 取出队首的 watcher\r\n        const watcher = queue.shift();\r\n        // 执行 run 方法\r\n        watcher.run();\r\n    }\r\n    // 到这里 watcher 队列刷新完毕\r\n    flushing = waiting = false;\r\n}\r\n/**\r\n * 将刷新 watcher 队列的函数或者用户调用 Vue.nextTick 方法传递的回调函数放入 callbacks 数组\r\n * 如果当前的浏览器任务队列中没有刷新 callbacks 的函数，则将 flushCallbacks 函数放入任务队列\r\n */\r\nfunction nextTick(cb) {\r\n    callbacks.push(cb);\r\n    if (!pending) { // 表明浏览器当前任务队列中没有刷新 callbacks 数组的函数\r\n        // 将 flushCallbacks 函数放入浏览器的微任务队列\r\n        Promise.resolve().then(flushCallbacks);\r\n        // 标识浏览器的微任务队列中已经存在 刷新 callbacks 数组的函数了\r\n        pending = true;\r\n    }\r\n}\r\n/**\r\n * 负责刷新 callbacks 数组的函数，执行 callbacks 数组中的所有函数\r\n */\r\nfunction flushCallbacks() {\r\n    // 表示浏览器任务队列中的 flushCallbacks 函数已经被拿到执行栈执行了\r\n    // 新的 flushCallbacks 函数可以进入浏览器的任务队列了\r\n    pending = false;\r\n    while (callbacks.length) {\r\n        // 拿出最头上的回调函数\r\n        const cb = callbacks.shift();\r\n        // 执行回调函数\r\n        cb();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/asyncUpdateQueue.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/compileToFunction.ts":
/*!************************************************!*\
  !*** ./src/compiler-Vue2/compileToFunction.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst generate_1 = __importDefault(__webpack_require__(/*! ./generate */ \"./src/compiler-Vue2/generate.ts\"));\r\nconst parse_1 = __importDefault(__webpack_require__(/*! ./parse */ \"./src/compiler-Vue2/parse.ts\"));\r\n/**\r\n  *\r\n  * 真正的vue中使用了二次提交的 设计结构\r\n  * 1. 在页面中的 DOM  和 虚拟DOM 是 一一对应的关系\r\n  * 2. AST + 数据  ->  VNode  [只要数据有变化, 就会生成 新的VNode]\r\n  * 3. 再将 新的VNode  和  旧的VNode 进行比较, 不同的更新, 相同的忽略\r\n  *\r\n  * 即 createRenderFn 返回一个生成虚拟DOM的render函数, 缓存AST, 作用:减少解析模板的次数\r\n  * 这个render 函数利用 AST 和 数据结合, 生成虚拟DOM\r\n  * 然后update就是进行比较新旧的VNode, 去执行渲染\r\n  *\r\n  * 解析模版字符串，得到 AST 语法树\r\n  * 将 AST 语法树生成渲染函数\r\n  * @param { String } template 模版字符串\r\n  * @returns 渲染函数\r\n*/\r\nfunction compileToFunction(template) {\r\n    // 解析模版，生成 ast\r\n    const ast = (0, parse_1.default)(template);\r\n    // 将 ast 生成渲染函数\r\n    const render = (0, generate_1.default)(ast);\r\n    return render;\r\n}\r\nexports[\"default\"] = compileToFunction;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/compileToFunction.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/generate.ts":
/*!***************************************!*\
  !*** ./src/compiler-Vue2/generate.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n/**\r\n * 从 ast 生成渲染函数\r\n * @param {*} ast ast 语法树\r\n * @returns 渲染函数\r\n */\r\nfunction generate(ast) {\r\n    // 渲染函数字符串形式\r\n    const renderStr = genElement(ast);\r\n    // 通过 new Function 将字符串形式的函数变成可执行函数，并用 with 为渲染函数扩展作用域链\r\n    return new Function(`with(this) { return ${renderStr} }`);\r\n}\r\nexports[\"default\"] = generate;\r\n/**\r\n * 解析 ast 生成 渲染函数\r\n * @param {*} ast 语法树\r\n * @returns {string} 渲染函数的字符串形式\r\n */\r\nfunction genElement(ast) {\r\n    const { tag, rawAttr, attr } = ast;\r\n    // 生成属性 Map 对象，静态属性 + 动态属性\r\n    // 比如<input id=\"input\" v-model=\"input\"/>,其中id等静态属性放在rawAttr中没有处理，v-model等动态属性处理以后放在attr中\r\n    const attrs = Object.assign(Object.assign({}, rawAttr), attr);\r\n    // 处理子节点，得到一个所有子节点渲染函数组成的数组\r\n    const children = genChildren(ast);\r\n    if (tag === 'slot') {\r\n        // 生成插槽的处理函数\r\n        return `_t(${JSON.stringify(attrs)}, [${children}])`;\r\n    }\r\n    // 生成 VNode 的可执行方法\r\n    return `_c('${tag}', ${JSON.stringify(attrs)}, [${children}])`;\r\n}\r\n/**\r\n * 处理 ast 节点的子节点，将子节点变成渲染函数\r\n * @param {*} ast 节点的 ast 对象\r\n * @returns [childNodeRender1, ....]\r\n */\r\nfunction genChildren(ast) {\r\n    const ret = [], { children } = ast;\r\n    // 遍历所有的子节点\r\n    if (children) {\r\n        for (let i = 0, len = children.length; i < len; i++) {\r\n            const child = children[i];\r\n            if (child.type === 3) {\r\n                // 文本节点\r\n                ret.push(`_v(${JSON.stringify(child)})`);\r\n            }\r\n            else if (child.type === 1) {\r\n                // 元素节点\r\n                ret.push(genElement(child));\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/generate.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/index.ts":
/*!************************************!*\
  !*** ./src/compiler-Vue2/index.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst compileToFunction_1 = __importDefault(__webpack_require__(/*! ./compileToFunction */ \"./src/compiler-Vue2/compileToFunction.ts\"));\r\nconst mountComponent_1 = __importDefault(__webpack_require__(/*! ./mountComponent */ \"./src/compiler-Vue2/mountComponent.ts\"));\r\n/**\r\n * 编译器\r\n */\r\nfunction mount(vm) {\r\n    if (!vm.$options.render) { // 没有提供 render 选项，则编译生成 render 函数\r\n        // 获取模版\r\n        let template = '';\r\n        if (vm.$options.template) {\r\n            // 存在template,模版存在\r\n            template = vm.$options.template;\r\n        }\r\n        else if (vm.$options.el) {\r\n            // 存在挂载点\r\n            // <div id=\"app\">XXX</div> outerHTML就是整个div标签\r\n            if (vm.$options.node) {\r\n                template = vm.$options.node.outerHTML;\r\n            }\r\n            else {\r\n                template = document.querySelector(vm.$options.el).outerHTML;\r\n                // 在实例上记录挂载点，this._update 中会用到\r\n                vm.$el = document.querySelector(vm.$options.el);\r\n            }\r\n        }\r\n        // 生成渲染函数\r\n        const render = (0, compileToFunction_1.default)(template);\r\n        // 将渲染函数挂载到 $options 上\r\n        vm.$options.render = render;\r\n    }\r\n    (0, mountComponent_1.default)(vm);\r\n}\r\nexports[\"default\"] = mount;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/index.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/mountComponent.ts":
/*!*********************************************!*\
  !*** ./src/compiler-Vue2/mountComponent.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst watcher_1 = __importDefault(__webpack_require__(/*! ../watcher */ \"./src/watcher.ts\"));\r\n/**\r\n * @param {*} vm Vue 实例\r\n */\r\nfunction mountComponent(vm) {\r\n    // 负责初始渲染和后续更新组件的的函数\r\n    const updateComponent = () => {\r\n        vm._update(vm._render());\r\n    };\r\n    // 实例化一个渲染 Watcher，当响应式数据更新时，这个更新函数会被执行\r\n    new watcher_1.default(updateComponent, { lazy: false });\r\n}\r\nexports[\"default\"] = mountComponent;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/mountComponent.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/parse.ts":
/*!************************************!*\
  !*** ./src/compiler-Vue2/parse.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/utils.ts\");\r\n/**\r\n * 解析模版字符串，生成 AST 语法树\r\n * @param {*} template 模版字符串\r\n * @returns {AST} root ast 语法树\r\n */\r\nfunction parse(template) {\r\n    // 存放所有的未配对的开始标签的 AST 对象\r\n    const stack = [];\r\n    // 最终的 AST 语法树\r\n    let root = null;\r\n    let html = template;\r\n    while (html.trim()) {\r\n        // 过滤注释标签\r\n        if (html.indexOf('<!--') === 0) {\r\n            // 说明开始位置是一个注释标签，忽略掉\r\n            html = html.slice(html.indexOf('-->') + 3);\r\n            continue;\r\n        }\r\n        // 匹配开始标签\r\n        const startIdx = html.indexOf('<');\r\n        if (startIdx === 0) { //匹配到正常标签，<div id=\"app\"></div>\r\n            if (html.indexOf('</') === 0) { //结束标签\r\n                // 说明是闭合标签\r\n                parseEnd();\r\n            }\r\n            else { //开始标签\r\n                // 处理开始标签\r\n                parseStartTag();\r\n            }\r\n        }\r\n        else if (startIdx > 0) {\r\n            // 说明在开始标签之间有一段文本内容，在 html 中找到下一个标签的开始位置\r\n            const nextStartIdx = html.indexOf('<');\r\n            // 如果栈为空，则说明这段文本不属于任何一个元素，直接丢掉，不做处理\r\n            if (stack.length) {\r\n                // 走到这里说说明栈不为空，则处理这段文本，并将其放到栈顶元素的肚子里\r\n                processChars(html.slice(0, nextStartIdx));\r\n            }\r\n            // 将文本节点从html中截取掉\r\n            html = html.slice(nextStartIdx);\r\n        }\r\n        else {\r\n            // 说明没有匹配到开始标签，整个 html 就是一段文本\r\n        }\r\n    }\r\n    return root;\r\n    // parseStartTag 函数的声明\r\n    /**\r\n   * 解析开始标签\r\n   * 比如： <div id=\"app\">...</div>，<h3></h3>\r\n   */\r\n    function parseStartTag() {\r\n        // 先找到开始标签的结束位置 >\r\n        const endIdx = html.indexOf('>');\r\n        // 截取开始标签里的内容 <内容>，标签名 + 属性，比如: div id=\"app\"\r\n        const content = html.slice(1, endIdx);\r\n        // 截断 html，将上面解析的内容从 html 字符串中删除\r\n        html = html.slice(endIdx + 1);\r\n        // 找到 第一个空格位置\r\n        const firstSpaceIdx = content.indexOf(' ');\r\n        // 标签名和属性字符串\r\n        let tagName = '', attrsStr = '';\r\n        if (firstSpaceIdx === -1) {\r\n            // 没有空格，则认为 content 就是标签名，标签没有属性，比如 <h3></h3> 这种情况，content = h3\r\n            tagName = content;\r\n            // 没有属性\r\n            attrsStr = '';\r\n        }\r\n        else {\r\n            // 属性名就是空格之前的\r\n            tagName = content.slice(0, firstSpaceIdx);\r\n            // content 的剩下的内容就都是属性了，比如 id=\"app\" xx=xx\r\n            attrsStr = content.slice(firstSpaceIdx + 1);\r\n        }\r\n        // 得到属性数组，[id=\"app\", xx=xx]\r\n        const attrs = attrsStr ? attrsStr.split(' ') : [];\r\n        // 进一步解析属性数组，得到一个 Map 对象\r\n        const attrMap = parseAttrs(attrs);\r\n        // 生成 AST 对象\r\n        const elementAst = generateAST(tagName, attrMap);\r\n        if (!root) { // 如果根节点不存在，说明当前节点为整个模版的第一个节点\r\n            root = elementAst;\r\n        }\r\n        // 将 ast 对象 push 到栈中，当遇到结束标签的时候就将栈顶的 ast 对象 pop 出来，它两就是一组标签\r\n        stack.push(elementAst);\r\n        // 自闭合标签，则直接调用 end 方法，进入闭合标签的处理截断，就不入栈了\r\n        if ((0, utils_1.isUnaryTag)(tagName)) {\r\n            processElement();\r\n        }\r\n    }\r\n    //parseAttrs函数的声明\r\n    /**\r\n     * 解析属性数组，得到一个属性 和 值组成的 Map 对象\r\n     * @param {*} attrs 属性数组，[id=\"app\", xx=\"xx\"]\r\n     */\r\n    function parseAttrs(attrs) {\r\n        const attrMap = {};\r\n        for (let attr of attrs) {\r\n            const [attrName, attrValue] = attr.split('=');\r\n            attrMap[attrName] = attrValue.replace(/\"/g, '');\r\n        }\r\n        return attrMap;\r\n    }\r\n    // generateAST函数声明\r\n    /**\r\n     * 生成 AST 对象\r\n     * @param {*} tagName 标签名\r\n     * @param {*} attrMap 标签组成的属性 map 对象\r\n     */\r\n    function generateAST(tagName, attrMap) {\r\n        return {\r\n            // 元素节点\r\n            type: 1,\r\n            // 标签\r\n            tag: tagName,\r\n            // 原始属性 map 对象，后续还需要进一步处理\r\n            rawAttr: attrMap,\r\n            // 子节点\r\n            children: [],\r\n        };\r\n    }\r\n    // parseEnd 函数的声明\r\n    /**\r\n     * 处理结束标签，比如: <div id=\"app\">...</div>\r\n    */\r\n    function parseEnd() {\r\n        // 将结束标签从 html 字符串中截掉\r\n        html = html.slice(html.indexOf('>') + 1);\r\n        // 处理栈顶元素\r\n        processElement();\r\n    }\r\n    // ...\r\n    // processElement 函数的声明\r\n    /**\r\n     * 处理元素的闭合标签时会调用该方法\r\n     * 进一步处理元素上的各个属性，将处理结果放到 attr 属性上\r\n     * 比如\r\n     * <input v-model=\"test\"/>\r\n     * <span v-bind:title=\"title\"></span>\r\n     * <button v-on:click=\"handleClick\"></button>\r\n     */\r\n    function processElement() {\r\n        // 弹出栈顶元素，进一步处理该元素\r\n        const curEle = stack.pop();\r\n        const stackLen = stack.length;\r\n        // 进一步处理 AST 对象中的 rawAttr 对象 { attrName: attrValue, ... }\r\n        const { tag, rawAttr } = curEle;\r\n        // 处理结果都放到 attr 对象上，并删掉 rawAttr 对象中相应的属性\r\n        curEle.attr = {};\r\n        // 属性对象的 key 组成的数组，比如['v-model', 'v-bind:title', 'v-on:click']\r\n        const propertyArr = Object.keys(rawAttr);\r\n        if (propertyArr.includes('v-model')) {\r\n            // 处理 v-model 指令\r\n            processVModel(curEle);\r\n        }\r\n        else if (propertyArr.find(item => item.match(/^v-bind:(.*)/))) {\r\n            // 处理 v-bind 指令，比如 <span v-bind:test=\"xx\" />\r\n            processVBind(curEle, RegExp.$1, rawAttr[`v-bind:${RegExp.$1}`]);\r\n        }\r\n        else if (propertyArr.find(item => item.match(/^v-on:(.*)/))) {\r\n            // 处理 v-on 指令，比如 <button v-on:click=\"add\"> add </button>\r\n            processVOn(curEle, RegExp.$1, rawAttr[`v-on:${RegExp.$1}`]);\r\n        }\r\n        // 处理插槽内容\r\n        processSlotContent(curEle);\r\n        // 节点处理完以后让其和父节点产生关系\r\n        if (stackLen) {\r\n            stack[stackLen - 1].children.push(curEle);\r\n            curEle.parent = stack[stackLen - 1];\r\n            // 如果节点存在 slotName，则说明该节点是组件传递给插槽的内容\r\n            // 将插槽信息放到组件节点的 rawAttr.scopedSlots 对象上\r\n            // 而这些信息在生成组件插槽的 VNode 时（renderSlot）会用到\r\n            if (curEle.slotName) {\r\n                const { parent, slotName, scopeSlot, children } = curEle;\r\n                // 这里关于 children 的操作，只是单纯为了避开 JSON.stringify 的循环引用问题\r\n                // 因为生成渲染函数时需要对 attr 执行 JSON.stringify 方法\\\r\n                const slotInfo = {\r\n                    slotName,\r\n                    scopeSlot,\r\n                    children: children.map((item) => {\r\n                        // 为了避免JSON.stringify(attr) 出现爆栈，因为会存在循环引用\r\n                        delete item.parent;\r\n                        return item;\r\n                    })\r\n                };\r\n                if (parent.rawAttr.scopedSlots) {\r\n                    parent.rawAttr.scopedSlots[curEle.slotName] = slotInfo;\r\n                }\r\n                else {\r\n                    parent.rawAttr.scopedSlots = { [curEle.slotName]: slotInfo };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //processChars 函数的声明\r\n    /**\r\n     * 处理文本\r\n     * @param {string} text\r\n     */\r\n    function processChars(text) {\r\n        // 去除空字符或者换行符的情况\r\n        if (!text.trim())\r\n            return;\r\n        // 构造文本节点的 AST 对象\r\n        const textAst = {\r\n            type: 3,\r\n            text,\r\n            expression: ''\r\n        };\r\n        if (text.match(/{{(.*)}}/)) {\r\n            // 说明是表达式，获取中间的文本\r\n            textAst.expression = RegExp.$1.trim();\r\n        }\r\n        // 将 ast 放到栈顶元素的children里\r\n        stack[stack.length - 1].children.push(textAst);\r\n    }\r\n    // processVModel 函数的声明\r\n    /**\r\n     * 处理 v-model 指令，将处理结果直接放到 curEle 对象身上\r\n     * @param {AST} curEle\r\n     */\r\n    function processVModel(curEle) {\r\n        const { tag, rawAttr, attr } = curEle;\r\n        const { type, 'v-model': vModelVal } = rawAttr;\r\n        if (tag === 'input') {\r\n            if (/text/.test(type)) {\r\n                // <input type=\"text\" v-model=\"inputVal\" />\r\n                attr.vModel = { tag, type: 'text', value: vModelVal };\r\n            }\r\n            else if (/checkbox/.test(type)) {\r\n                // <input type=\"checkbox\" v-model=\"isChecked\" />\r\n                attr.vModel = { tag, type: 'checkbox', value: vModelVal };\r\n            }\r\n        }\r\n        else if (tag === 'textarea') {\r\n            // <textarea v-model=\"test\" />\r\n            attr.vModel = { tag, value: vModelVal };\r\n        }\r\n        else if (tag === 'select') {\r\n            // <select v-model=\"selectedValue\">...</select>\r\n            attr.vModel = { tag, value: vModelVal };\r\n        }\r\n    }\r\n    // processVBind 函数的声明\r\n    /**\r\n     * 处理 v-bind 指令\r\n     * @param {*} curEle 当前正在处理的 AST 对象\r\n     * @param {*} bindKey v-bind:key 中的 key\r\n     * @param {*} bindVal v-bind:key = val 中的 val\r\n     */\r\n    function processVBind(curEle, bindKey, bindVal) {\r\n        curEle.attr.vBind = { [bindKey]: bindVal };\r\n    }\r\n    // processVOn 函数的声明\r\n    /**\r\n     * 处理 v-on 指令\r\n     * @param {*} curEle 当前被处理的 AST 对象\r\n     * @param {*} vOnKey v-on:key 中的 key\r\n     * @param {*} vOnVal v-on:key=\"val\" 中的 val\r\n     */\r\n    function processVOn(curEle, vOnKey, vOnVal) {\r\n        curEle.attr.vOn = { [vOnKey]: vOnVal };\r\n    }\r\n}\r\nexports[\"default\"] = parse;\r\n/**\r\n * 处理插槽\r\n * <scope-slot>\r\n *   <template v-slot:default=\"scopeSlot\">\r\n *     <div>{{ scopeSlot }}</div>\r\n *   </template>\r\n * </scope-slot>\r\n * @param { AST } el 节点的 AST 对象\r\n */\r\nfunction processSlotContent(el) {\r\n    // 注意，具有 v-slot:xx 属性的 template 只能是组件的根元素，这里不做判断\r\n    if (el.tag === 'template') { // 获取插槽信息\r\n        // 属性 map 对象\r\n        const attrMap = el.rawAttr;\r\n        // 遍历属性 map 对象，找出其中的 v-slot 指令信息\r\n        for (let key in attrMap) {\r\n            if (key.match(/v-slot:(.*)/)) { // 说明 template 标签上 v-slot 指令\r\n                // 获取指令后的插槽名称和值，比如: v-slot:default=xx\r\n                // default\r\n                const slotName = el.slotName = RegExp.$1;\r\n                // xx\r\n                el.scopeSlot = attrMap[`v-slot:${slotName}`];\r\n                // 直接 return，因为该标签上只可能有一个 v-slot 指令\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/parse.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/patch.ts":
/*!************************************!*\
  !*** ./src/compiler-Vue2/patch.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst myMVVM_1 = __importDefault(__webpack_require__(/*! ../myMVVM */ \"./src/myMVVM.ts\"));\r\nconst utils_1 = __webpack_require__(/*! ../utils */ \"./src/utils.ts\");\r\n/**\r\n * 负责组件的首次渲染和后续更新\r\n * @param {VNode} oldVnode 老的 VNode,首次渲染olVNode是document.querySelector(this.$options.el)\r\n * 结构不一样，暂时不做类型声明\r\n * @param {VNode} vnode 新的 VNode\r\n */\r\nfunction patch(oldVnode, vnode) {\r\n    if (oldVnode && !vnode) {\r\n        // 老节点存在，新节点不存在，则销毁组件\r\n        return;\r\n    }\r\n    if (!oldVnode) { // oldVnode 不存在，说明是子组件首次渲染\r\n        createElm(vnode, null, null);\r\n    }\r\n    else {\r\n        // nodeType是节点上的原始属性\r\n        if (oldVnode.nodeType) { // 真实节点，则表示首次渲染根组件\r\n            // 父节点\r\n            const parent = oldVnode.parentNode;\r\n            // 参考节点是第一个script标签，确定将body放到script节点的前面\r\n            const referNode = oldVnode.nextSibling;\r\n            // 创建元素，将vnode变成真实节点，并添加到父元素节点内\r\n            createElm(vnode, parent, referNode);\r\n            // 移除老的vnode, 其实就是模板节点\r\n            parent.removeChild(oldVnode);\r\n        }\r\n        else {\r\n            // 后续的更新\r\n            patchVnode(oldVnode, vnode);\r\n        }\r\n    }\r\n}\r\nexports[\"default\"] = patch;\r\n/**\r\n * 负责组件的首次渲染和后续更新\r\n * @param {*} vnode vnode\r\n * @param {*} parent vonde的父节点\r\n * @param {*} referNode 参考节点\r\n */\r\nfunction createElm(vnode, parent, referNode) {\r\n    // 在 vnode 上记录自己的父节点是谁\r\n    vnode.parent = parent;\r\n    // 创建自定义组件， 如果是非组件， 就继续后面的流程\r\n    if (createComponent(vnode))\r\n        return;\r\n    // 走到这里说明当前节点是一个原生标签， 走DOM API 创建这些标签， 然后添加到父节点内\r\n    const { tag, attr, children, text } = vnode;\r\n    if (text) {\r\n        // 说明是文本节点\r\n        // 创建文本节点， 并插入到父节点内\r\n        vnode.elm = createTextNode(vnode);\r\n    }\r\n    else {\r\n        // 首选的元素节点\r\n        // 创建元素\r\n        vnode.elm = document.createElement(tag);\r\n        // 对元素设置属性\r\n        setAttributes(attr, vnode);\r\n        // 循环递归创建当前节点的所有子节点\r\n        if (children) {\r\n            for (let i = 0, len = children.length; i < len; i++) {\r\n                createElm(children[i], vnode.elm, null);\r\n            }\r\n        }\r\n    }\r\n    // 节点创建完毕，将创建的节点插入到父节点内\r\n    if (parent) {\r\n        const elm = vnode.elm;\r\n        if (referNode) {\r\n            // 如果存在参考节点，放到参考节点之前\r\n            parent.insertBefore(elm, referNode);\r\n        }\r\n        else {\r\n            // 没有参考节点，就直接放\r\n            parent.appendChild(elm);\r\n        }\r\n    }\r\n}\r\n/**\r\n * 创建一个自定义组件\r\n * @param vnode\r\n */\r\nfunction createComponent(vnode) {\r\n    if (vnode.tag && !(0, utils_1.isReserveTag)(vnode.tag)) {\r\n        // 获取组件的基本信息\r\n        const { tag, context: { $options: { components } } } = vnode;\r\n        const compOptions = components[tag];\r\n        // 直接通过 new Vue ， 源码中是 extend方法\r\n        const compIns = new myMVVM_1.default(compOptions);\r\n        // 把父组件的 vnode 放到子组件的实例上,处理插槽时会用到\r\n        compIns._parentVnode = vnode;\r\n        // 由于component上面没有el,不会挂载，需要手动挂载\r\n        compIns.$mount();\r\n        // 记录字组件 vnode 的父节点信息\r\n        // compIns._vnode.parent = vnode.parent;\r\n        // 将子组件添加到父节点内\r\n        if (vnode.parent) {\r\n            vnode.parent.appendChild(compIns._vnode.elm);\r\n        }\r\n    }\r\n}\r\n// 创建文本节点\r\nfunction createTextNode(textVnode) {\r\n    let { text } = textVnode, textNode = null;\r\n    if (text && text.expression) {\r\n        // 说明当前文本节点含有表达式\r\n        // 这个表达式时一个响应式数据\r\n        const value = textVnode.context[text.expression];\r\n        textNode = document.createTextNode(\r\n        // 如果是对象做序列化\r\n        typeof value === \"object\" ? JSON.stringify(value) : value);\r\n    }\r\n    else {\r\n        // 纯文本节点\r\n        if (text && text.text)\r\n            textNode = document.createTextNode(text.text);\r\n    }\r\n    return textNode;\r\n}\r\n/**\r\n * 给节点设置属性\r\n */\r\nfunction setAttributes(attr, vnode) {\r\n    // 遍历属性对象， 普通属性， 直接设置， 如果是指令， 特殊处理\r\n    for (const name in attr) {\r\n        if (name === \"vModel\") {\r\n            setVModel(attr[name].tag, attr[name].value, vnode);\r\n        }\r\n        else if (name === \"vBind\") {\r\n            setVBind(vnode);\r\n        }\r\n        else if (name === \"vOn\") {\r\n            setVOn(vnode);\r\n        }\r\n        else {\r\n            // 普通指令\r\n            vnode.elm.setAttribute(name, attr[name]);\r\n        }\r\n    }\r\n}\r\n/**\r\n * v-model 原理\r\n * @param tag\r\n * @param value\r\n * @param vnode\r\n */\r\nfunction setVModel(tag, value, vnode) {\r\n    const { context: vm, elm } = vnode;\r\n    if (tag === \"select\") {\r\n        // 下拉框\r\n        // 当前select标签还在创建，异步，设置时间延后\r\n        Promise.resolve().then(() => {\r\n            elm.value = vm[value];\r\n        });\r\n        elm.addEventListener(\"change\", function () {\r\n            vm[value] = elm.value;\r\n        });\r\n    }\r\n    else if (tag === \"input\" && vnode.elm.type === \"text\") {\r\n        // 文本输入框\r\n        elm.value = vm[value]; // 设置初始值， 数据变化触发监听事件，改变\r\n        elm.addEventListener(\"input\", function () {\r\n            vm[value] = elm.value;\r\n        });\r\n    }\r\n    else if (tag === \"input\" && vnode.elm.type === \"checkbox\") {\r\n        elm.checked = vm[value];\r\n        elm.addEventListener(\"change\", function () {\r\n            vm[value] = elm.checked;\r\n        });\r\n    }\r\n}\r\nfunction setVBind(vnode) {\r\n    const { attr: { vBind }, elm, context: vm, } = vnode;\r\n    for (const attrName in vBind) {\r\n        elm.setAttribute(attrName, vm[vBind[attrName]]);\r\n        elm.removeAttribute(`v-bind:${attrName}`);\r\n    }\r\n}\r\nfunction setVOn(vnode) {\r\n    const { attr: { vOn }, elm, context: vm, } = vnode;\r\n    for (const eventName in vOn) {\r\n        elm.addEventListener(eventName, function (...args) {\r\n            vm.$options.methods[vOn[eventName]].apply(vm, args);\r\n        });\r\n    }\r\n}\r\n/**\r\n * 对比新老节点，找出其中的不同，然后更新老节点\r\n * @param {*} oldVnode 老节点的 vnode\r\n * @param {*} vnode 新节点的 vnode\r\n */\r\nfunction patchVnode(oldVnode, vnode) {\r\n    // 如果新老节点相同，则直接结束\r\n    if (oldVnode === vnode)\r\n        return;\r\n    // 将老 vnode 上的真实节点同步到新的 vnode 上，否则，后续更新的时候会出现 vnode.elm 为空的现象\r\n    vnode.elm = oldVnode.elm;\r\n    // 走到这里说明新老节点不一样，则获取它们的孩子节点，比较孩子节点\r\n    const ch = vnode.children;\r\n    const oldCh = oldVnode.children;\r\n    if (!vnode.text) { // 新节点不存在文本节点\r\n        if (ch && oldCh) { // 说明新老节点都有孩子\r\n            // diff\r\n            updateChildren(ch, oldCh);\r\n        }\r\n        else if (ch) { // 老节点没孩子，新节点有孩子\r\n            // 增加孩子节点\r\n        }\r\n        else { // 新节点没孩子，老节点有孩子\r\n            // 删除这些孩子节点\r\n        }\r\n    }\r\n    else { // 新节点存在文本节点\r\n        if (vnode.text.expression) { // 说明存在表达式\r\n            // 获取表达式的新值\r\n            const value = JSON.stringify(vnode.context[vnode.text.expression]);\r\n            // 旧值\r\n            try {\r\n                const oldValue = oldVnode.elm.textContent;\r\n                if (value !== oldValue) { // 新老值不一样，则更新\r\n                    oldVnode.elm.textContent = value;\r\n                }\r\n            }\r\n            catch (_a) {\r\n                // 防止更新时遇到插槽，导致报错\r\n                // 目前不处理插槽数据的响应式更新\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * diff，比对孩子节点，找出不同点，然后将不同点更新到老节点上\r\n * @param {*} ch 新 vnode 的所有孩子节点\r\n * @param {*} oldCh 老 vnode 的所有孩子节点\r\n */\r\nfunction updateChildren(ch, oldCh) {\r\n    if (ch && oldCh) {\r\n    }\r\n    // 四个游标\r\n    // 新孩子节点的开始索引，叫 新开始\r\n    let newStartIdx = 0;\r\n    // 新结束\r\n    let newEndIdx = ch.length - 1;\r\n    // 老开始\r\n    let oldStartIdx = 0;\r\n    // 老结束\r\n    let oldEndIdx = oldCh.length - 1;\r\n    // 循环遍历新老节点，找出节点中不一样的地方，然后更新\r\n    while (newStartIdx <= newEndIdx && oldStartIdx <= oldEndIdx) { // 根为 web 中的 DOM 操作特点，做了四种假设，降低时间复杂度\r\n        // 新开始节点\r\n        const newStartNode = ch[newStartIdx];\r\n        // 新结束节点\r\n        const newEndNode = ch[newEndIdx];\r\n        // 老开始节点\r\n        const oldStartNode = oldCh[oldStartIdx];\r\n        // 老结束节点\r\n        const oldEndNode = oldCh[oldEndIdx];\r\n        if (sameVNode(newStartNode, oldStartNode)) { // 假设新开始和老开始是同一个节点\r\n            // 对比这两个节点，找出不同然后更新\r\n            patchVnode(oldStartNode, newStartNode);\r\n            // 移动游标\r\n            oldStartIdx++;\r\n            newStartIdx++;\r\n        }\r\n        else if (sameVNode(newStartNode, oldEndNode)) { // 假设新开始和老结束是同一个节点\r\n            patchVnode(oldEndNode, newStartNode);\r\n            // 将老结束移动到新开始的位置\r\n            oldEndNode.elm.parentNode.insertBefore(oldEndNode.elm, oldCh[newStartIdx].elm);\r\n            // 移动游标\r\n            newStartIdx++;\r\n            oldEndIdx--;\r\n        }\r\n        else if (sameVNode(newEndNode, oldStartNode)) { // 假设新结束和老开始是同一个节点\r\n            patchVnode(oldStartNode, newEndNode);\r\n            // 将老开始移动到新结束的位置\r\n            oldStartNode.elm.parentNode.insertBefore(oldStartNode.elm, oldCh[newEndIdx].elm.nextSibling);\r\n            // 移动游标\r\n            newEndIdx--;\r\n            oldStartIdx++;\r\n        }\r\n        else if (sameVNode(newEndNode, oldEndNode)) { // 假设新结束和老结束是同一个节点\r\n            patchVnode(oldEndNode, newEndNode);\r\n            // 移动游标\r\n            newEndIdx--;\r\n            oldEndIdx--;\r\n        }\r\n        else {\r\n            // 上面几种假设都没命中，则老老实的遍历，找到那个相同元素\r\n        }\r\n    }\r\n    // 跳出循环，说明有一个节点首先遍历结束了\r\n    if (newStartIdx < newEndIdx) { // 说明老节点先遍历结束，则将剩余的新节点添加到 DOM 中\r\n    }\r\n    if (oldStartIdx < oldEndIdx) { // 说明新节点先遍历结束，则将剩余的这些老节点从 DOM 中删掉\r\n    }\r\n}\r\n/**\r\n * 判断两个节点是否相同\r\n * 这里的判读比较简单，只做了 key 和 标签的比较\r\n */\r\nfunction sameVNode(n1, n2) {\r\n    return n1.key == n2.key && n1.tag === n2.tag;\r\n}\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/patch.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/renderHelper.ts":
/*!*******************************************!*\
  !*** ./src/compiler-Vue2/renderHelper.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst vnode_1 = __importDefault(__webpack_require__(/*! ./vnode */ \"./src/compiler-Vue2/vnode.ts\"));\r\n/**\r\n * 在 Vue 实例上安装运行时的渲染帮助函数，比如 _c、_v，这些函数会生成 Vnode\r\n * @param {VueContructor} target Vue 实例\r\n */\r\nfunction renderHelper(target) {\r\n    target._c = createElement;\r\n    target._v = createTextNode;\r\n    target._t = renderSlot;\r\n}\r\nexports[\"default\"] = renderHelper;\r\n/**\r\n * 根据标签信息创建 Vnode\r\n * @param {string} tag 标签名\r\n * @param {Map} attr 标签的属性 Map 对象\r\n * @param {Array<Render>} children 所有的子节点的渲染函数\r\n */\r\nfunction createElement(tag, attr, children) {\r\n    return (0, vnode_1.default)(tag, attr, children, this, null);\r\n}\r\n/**\r\n * 生成文本节点的 VNode\r\n * @param {*} textAst 文本节点的 AST 对象\r\n */\r\nfunction createTextNode(textAst) {\r\n    return (0, vnode_1.default)(null, null, null, this, textAst);\r\n}\r\n/**\r\n * 插槽的原理其实很简单，难点在于实现\r\n * 其原理就是生成 VNode，难点在于生成 VNode 之前的各种解析，也就是数据准备阶段\r\n * 生成插槽的的 VNode\r\n * @param {*} attrs 插槽的属性\r\n * @param {*} children 插槽所有子节点的 ast 组成的数组\r\n */\r\nfunction renderSlot(attrs, children) {\r\n    // 父组件 VNode 的 attr 信息\r\n    const parentAttr = this._parentVnode.attr;\r\n    let vnode = null;\r\n    if (parentAttr.scopedSlots) { // 说明给当前组件的插槽传递了内容\r\n        // 获取插槽信息\r\n        const slotName = attrs.name;\r\n        const slotInfo = parentAttr.scopedSlots[slotName];\r\n        // 这里的逻辑稍微有点绕，建议打开调试，查看一下数据结构，理清对应的思路\r\n        // 这里比较绕的逻辑完全是为了实现插槽这个功能，和插槽本身的原理没关系\r\n        this[slotInfo.scopeSlot] = this[Object.keys(attrs.vBind)[0]];\r\n        vnode = genVNode(slotInfo.children, this);\r\n    }\r\n    else { // 插槽默认内容\r\n        // 将 children 变成 vnode 数组\r\n        vnode = genVNode(children, this);\r\n    }\r\n    // 如果 children 长度为 1，则说明插槽只有一个子节点\r\n    if (children.length === 1)\r\n        return vnode[0];\r\n    return createElement.call(this, 'div', {}, vnode);\r\n}\r\n/**\r\n * 将一批 ast 节点(数组)转换成 vnode 数组\r\n * @param {Array<Ast>} childs 节点数组\r\n * @param {*} vm 组件实例\r\n * @returns vnode 数组\r\n */\r\nfunction genVNode(childs, vm) {\r\n    const vnode = [];\r\n    for (let i = 0, len = childs.length; i < len; i++) {\r\n        const { tag, attr, children, text } = childs[i];\r\n        if (text) { // 文本节点\r\n            if (typeof text === 'string') { // text 为字符串\r\n                // 构造文本节点的 AST 对象\r\n                const textAst = {\r\n                    type: 3,\r\n                    text,\r\n                    expression: '',\r\n                    rawAttr: null,\r\n                    tag: '',\r\n                    attr: null,\r\n                    children: null,\r\n                    slotName: null,\r\n                    scopeSlot: null\r\n                };\r\n                if (text.match(/{{(.*)}}/)) {\r\n                    // 说明是表达式\r\n                    textAst.expression = RegExp.$1.trim();\r\n                }\r\n                vnode.push(createTextNode.call(vm, textAst));\r\n            }\r\n            else { // text 为文本节点的 ast 对象\r\n                vnode.push(createTextNode.call(vm, text));\r\n            }\r\n        }\r\n        else { // 元素节点\r\n            vnode.push(createElement.call(vm, tag, attr, genVNode(children, vm)));\r\n        }\r\n    }\r\n    return vnode;\r\n}\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/renderHelper.ts?");

/***/ }),

/***/ "./src/compiler-Vue2/vnode.ts":
/*!************************************!*\
  !*** ./src/compiler-Vue2/vnode.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n/**\r\n * VNode\r\n * @param {*} tag 标签名\r\n * @param {*} attr 属性 Map 对象\r\n * @param {*} children 子节点组成的 VNode\r\n * @param {*} text 文本节点的 ast 对象\r\n * @param {*} context Vue 实例\r\n * @returns VNode\r\n */\r\nfunction VNode(tag, attr, children, context, text) {\r\n    return {\r\n        // 标签\r\n        tag,\r\n        // 属性 Map 对象\r\n        attr,\r\n        // 父节点\r\n        parent: null,\r\n        // 子节点组成的 Vnode 数组\r\n        children,\r\n        // 文本节点的 Ast 对象\r\n        text,\r\n        // Vnode 的真实节点\r\n        elm: null,\r\n        // Vue 实例\r\n        context\r\n    };\r\n}\r\nexports[\"default\"] = VNode;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/compiler-Vue2/vnode.ts?");

/***/ }),

/***/ "./src/defineReactive.ts":
/*!*******************************!*\
  !*** ./src/defineReactive.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst dep_1 = __importDefault(__webpack_require__(/*! ./dep */ \"./src/dep.ts\"));\r\nconst observe_1 = __importDefault(__webpack_require__(/*! ./observe */ \"./src/observe.ts\"));\r\n/**\r\n * 通过 Object.defineProperty 为 obj.key 设置 getter、setter 拦截\r\n */\r\nfunction defineReactive(obj, key, val) {\r\n    // 递归调用 observe，处理 val 仍然为对象的情况\r\n    const childOb = (0, observe_1.default)(val);\r\n    const dep = new dep_1.default();\r\n    Object.defineProperty(obj, key, {\r\n        // 当发现 obj.key 的读取行为时，会被 get 拦截\r\n        get() {\r\n            if (dep_1.default.prototype.target) {\r\n                dep.depend();\r\n                // 如果存在子ob，则顺道把子对象的依赖一起收集\r\n                if (childOb) {\r\n                    childOb.dep.depend();\r\n                }\r\n            }\r\n            console.log(`getter: key = ${key}`);\r\n            return val;\r\n        },\r\n        // 当发生 obj.key = xx 的赋值行为时，会被 set 拦截\r\n        set(newV) {\r\n            console.log(`setter: ${key} = ${newV}`);\r\n            if (newV === val)\r\n                return;\r\n            val = newV;\r\n            // 对新值进行响应式处理，这里针对的是新值为非原始值的情况，比如 val 为对象、数组\r\n            (0, observe_1.default)(val);\r\n            dep.notify();\r\n        }\r\n    });\r\n}\r\nexports[\"default\"] = defineReactive;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/defineReactive.ts?");

/***/ }),

/***/ "./src/dep.ts":
/*!********************!*\
  !*** ./src/dep.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.popTarget = exports.pushTarget = void 0;\r\n/**\r\n * Dep\r\n * Vue1.0 中 key 和 Dep 是一一对应关系，举例来说：\r\n * new Vue({\r\n *   data() {\r\n *     return {\r\n *       t1: xx,\r\n *       t2: {\r\n *         tt2: xx\r\n *       },\r\n *       arr: [1, 2, 3, { t3: xx }]\r\n *     }\r\n *   }\r\n * })\r\n * data 函数 return 回来的对象是一个 dep\r\n * 对象中的 key => t1、t2、tt2、arr、t3 都分别对应一个 dep\r\n */\r\nclass Dep {\r\n    constructor() {\r\n        this.depend = function () {\r\n            // 防止 Watcher 实例被重复收集\r\n            if (this.watchers.includes(Dep.prototype.target))\r\n                return;\r\n            // 收集 Watcher 实例\r\n            this.watchers.push(Dep.prototype.target);\r\n        };\r\n        this.notify = function () {\r\n            for (let watcher of this.watchers) {\r\n                watcher.update();\r\n            }\r\n        };\r\n        // 存储当前 dep 实例收集的所有 watcher\r\n        this.watchers = [],\r\n            this.target = null;\r\n    }\r\n}\r\nexports[\"default\"] = Dep;\r\n// 存储所有的 Dep.target\r\n// 为什么会有多个 Dep.target?\r\n// 组件会产生一个渲染 Watcher，在渲染的过程中如果处理到用户 Watcher，\r\n// 比如 computed 计算属性，这时候会执行 evalute -> get\r\n// 假如直接赋值 Dep.target，那 Dep.target 的上一个值 —— 渲染 Watcher 就会丢失\r\n// 造成在 computed 计算属性之后渲染的响应式数据无法完成依赖收集\r\nlet targetStack = [];\r\n/**\r\n * 备份本次传递进来的 Watcher，并将其赋值给 Dep.target\r\n * @param {*} target Watcher 实例\r\n */\r\nfunction pushTarget(target) {\r\n    // 备份传递进来的 Watcher\r\n    targetStack.push(target);\r\n    Dep.prototype.target = target;\r\n}\r\nexports.pushTarget = pushTarget;\r\n/**\r\n * 将 Dep.target 重置为上一个 Watcher 或者 null\r\n */\r\nfunction popTarget() {\r\n    targetStack.pop();\r\n    Dep.prototype.target = targetStack[targetStack.length - 1];\r\n}\r\nexports.popTarget = popTarget;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/dep.ts?");

/***/ }),

/***/ "./src/initComputed.ts":
/*!*****************************!*\
  !*** ./src/initComputed.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst watcher_1 = __importDefault(__webpack_require__(/*! ./watcher */ \"./src/watcher.ts\"));\r\n/**\r\n * 初始化 computed 配置项\r\n * 为每一项实例化一个 Watcher，并将其 computed 属性代理到 Vue 实例上\r\n * 结合 watcher.dirty 和 watcher.evalute 实现 computed 缓存\r\n * @param {*} vm Vue 实例\r\n */\r\nfunction initComputed(vm) {\r\n    // 获取 computed 配置项\r\n    const computed = vm.$options.computed;\r\n    // 记录 watcher\r\n    const watcher = vm._watcher = Object.create(null);\r\n    // 遍历 computed 对象\r\n    for (let key in computed) {\r\n        // 实例化 Watcher，回调函数默认懒执行\r\n        watcher[key] = new watcher_1.default(computed[key], { lazy: true }, vm);\r\n        // 将 computed 的属性 key 代理到 Vue 实例上\r\n        defineComputed(vm, key);\r\n    }\r\n}\r\nexports[\"default\"] = initComputed;\r\n/**\r\n * 将计算属性代理到 Vue 实例上，并结合watcher实现computed属性的缓存\r\n * @param {*} vm Vue 实例\r\n * @param {*} key computed 的计算属性\r\n */\r\nfunction defineComputed(vm, key) {\r\n    // 属性描述符\r\n    const descriptor = {\r\n        // 当render函数读取到计算属性时，执行这个get函数\r\n        get: function () {\r\n            const watcher = vm._watcher[key];\r\n            if (watcher.dirty) { // 说明当前 computed 回调函数在本次渲染周期内没有被执行过\r\n                // 执行 evalute，通知 watcher 执行 computed 回调函数，得到回调函数返回值\r\n                watcher.evalute();\r\n            }\r\n            return watcher.value;\r\n        },\r\n    };\r\n    // 将计算属性代理到 Vue 实例上，就可以通过vm.xxx的方式访问了\r\n    Object.defineProperty(vm, key, descriptor);\r\n}\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/initComputed.ts?");

/***/ }),

/***/ "./src/initData.ts":
/*!*************************!*\
  !*** ./src/initData.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst observe_1 = __importDefault(__webpack_require__(/*! ./observe */ \"./src/observe.ts\"));\r\nconst proxy_1 = __webpack_require__(/*! ./proxy */ \"./src/proxy.ts\");\r\n/**\r\n * 1、初始化 options.data\r\n * 2、代理 data 对象上的各个属性到 Vue 实例\r\n * 3、给 data 对象上的各个属性设置响应式能力\r\n * @param {*} vm\r\n */\r\nfunction initData(vm) {\r\n    // 获取 data 选项\r\n    let { data } = vm.$options;\r\n    // 设置 vm._data 选项，保证它的值肯定是一个对象\r\n    if (!data) {\r\n        vm._data = {};\r\n    }\r\n    else {\r\n        vm._data = typeof data === 'function' ? data() : data;\r\n    }\r\n    // 代理，将 data 对象上的的各个属性代理到 Vue 实例上，支持 通过 this.xx 的方式访问\r\n    for (let key in vm._data) {\r\n        (0, proxy_1.proxy)(vm, '_data', key);\r\n    }\r\n    // 设置响应式\r\n    (0, observe_1.default)(vm._data);\r\n}\r\nexports[\"default\"] = initData;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/initData.ts?");

/***/ }),

/***/ "./src/myMVVM.ts":
/*!***********************!*\
  !*** ./src/myMVVM.ts ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst index_1 = __importDefault(__webpack_require__(/*! ./compiler-Vue2/index */ \"./src/compiler-Vue2/index.ts\"));\r\nconst patch_1 = __importDefault(__webpack_require__(/*! ./compiler-Vue2/patch */ \"./src/compiler-Vue2/patch.ts\"));\r\nconst renderHelper_1 = __importDefault(__webpack_require__(/*! ./compiler-Vue2/renderHelper */ \"./src/compiler-Vue2/renderHelper.ts\"));\r\nconst initComputed_1 = __importDefault(__webpack_require__(/*! ./initComputed */ \"./src/initComputed.ts\"));\r\nconst initData_1 = __importDefault(__webpack_require__(/*! ./initData */ \"./src/initData.ts\"));\r\n/**\r\n * Vue 构造函数\r\n * @param {*} options new Vue(options) 时传递的配置对象\r\n */\r\nclass Vue {\r\n    constructor(options) {\r\n        this._init(options);\r\n    }\r\n    /**\r\n   * 初始化配置对象\r\n   * @param {*} options\r\n   */\r\n    _init(options) {\r\n        // 将 options 配置挂载到 Vue 实例上\r\n        this.$options = options;\r\n        // 将patch方法挂载到Vue实例上\r\n        this.__patch__ = patch_1.default;\r\n        // 初始化 options.data\r\n        // 代理 data 对象上的各个属性到 Vue 实例\r\n        // 给 data 对象上的各个属性设置响应式能力\r\n        (0, initData_1.default)(this);\r\n        // // 初始化 computed 选项，并将计算属性代理到 Vue 实例上\r\n        // 结合 watcher 实现缓存\r\n        (0, initComputed_1.default)(this);\r\n        // 安装运行时生成VNode的渲染工具函数\r\n        (0, renderHelper_1.default)(this);\r\n        if (this.$options.el) {\r\n            this.$mount();\r\n        }\r\n    }\r\n    // 负责执行 vm.$options.render 函数\r\n    _render() {\r\n        return this.$options.render.apply(this);\r\n    }\r\n    //  * 由 render 函数生成的 VNode 虚拟DOM\r\n    _update(vnode) {\r\n        // 获取旧的vnode节点\r\n        const prevVNode = this._vnode;\r\n        // 设置新的vnode\r\n        this._vnode = vnode;\r\n        if (!prevVNode) { //老的VNode不存在，说明是首次更新，将挂载点和vnode传入\r\n            this.__patch__(document.querySelector(this.$options.el), vnode);\r\n        }\r\n        else { //老的VNode存在，说明时后续更新\r\n            this.__patch__(prevVNode, vnode);\r\n        }\r\n    }\r\n    $mount() {\r\n        (0, index_1.default)(this);\r\n    }\r\n}\r\nexports[\"default\"] = Vue;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/myMVVM.ts?");

/***/ }),

/***/ "./src/observe.ts":
/*!************************!*\
  !*** ./src/observe.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst observer_1 = __importDefault(__webpack_require__(/*! ./observer */ \"./src/observer.ts\"));\r\n/**\r\n * 通过 Observer 类为对象设置响应式能力\r\n * @returns Observer 实例\r\n */\r\nfunction observe(value) {\r\n    // 避免无限递归\r\n    // 当 value 不是对象直接结束递归\r\n    if (typeof value !== 'object')\r\n        return;\r\n    // value.__ob__ 是 Observer 实例\r\n    // 如果 value.__ob__ 属性已经存在，说明 value 对象已经具备响应式能力，直接返回已有的响应式对象\r\n    if (value.__ob__)\r\n        return value.__ob__;\r\n    const obj = new observer_1.default(value);\r\n    // 返回 Observer 实例\r\n    return obj;\r\n}\r\nexports[\"default\"] = observe;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/observe.ts?");

/***/ }),

/***/ "./src/observer.ts":
/*!*************************!*\
  !*** ./src/observer.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst defineReactive_1 = __importDefault(__webpack_require__(/*! ./defineReactive */ \"./src/defineReactive.ts\"));\r\nconst dep_1 = __importDefault(__webpack_require__(/*! ./dep */ \"./src/dep.ts\"));\r\nconst observe_1 = __importDefault(__webpack_require__(/*! ./observe */ \"./src/observe.ts\"));\r\nconst protoArgument_1 = __importDefault(__webpack_require__(/*! ./protoArgument */ \"./src/protoArgument.ts\"));\r\n/**\r\n * 为普通对象或者数组设置响应式的入口\r\n */\r\nclass Observer {\r\n    constructor(value) {\r\n        // debugger\r\n        this.observeArray = function (arr) {\r\n            for (let item of arr) {\r\n                (0, observe_1.default)(item);\r\n            }\r\n        };\r\n        this.value = value;\r\n        this.dep = new dep_1.default();\r\n        Object.defineProperty(value, '__ob__', {\r\n            value: this,\r\n            // 防止递归的时候处理__ob__，从而进行无限递归\r\n            // 在页面显示的时候，不想显示__ob__属性\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true\r\n        });\r\n        // 对对象中的属性挂载dep\r\n        if (Array.isArray(value)) {\r\n            // 数组响应式\r\n            (0, protoArgument_1.default)(value);\r\n            // 遍历数组的每个元素，为每个元素设置响应式\r\n            // 其实这里是为了处理元素为对象的情况，以达到 this.arr[idx].xx 是响应式的目的\r\n            // arr = [1,2,{a: 'a value}]\r\n            // this.arr[2].a = 'new value'\r\n            this.observeArray(value);\r\n        }\r\n        else {\r\n            // 对象响应式\r\n            for (let key in value) {\r\n                // 遍历对象的每个属性，为这些属性设置 getter、setter 拦截\r\n                (0, defineReactive_1.default)(value, key, value[key]);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports[\"default\"] = Observer;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/observer.ts?");

/***/ }),

/***/ "./src/protoArgument.ts":
/*!******************************!*\
  !*** ./src/protoArgument.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n/**\r\n * 通过拦截数组的七个方法来实现\r\n */\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n// 数组默认原型对象\r\nconst arrayProto = Array.prototype;\r\n// 以数组默认原型对象为原型创建一个新的对象\r\nconst arrayMethods = Object.create(arrayProto);\r\n// 被 patch 的七个方法，通过拦截这七个方法来实现数组响应式\r\n// 为什么是这七个方法？因为只有这七个方法是能更改数组本身的，像 cancat 这些方法都是会返回一个新的数组，不会改动数组本身\r\nconst methodsToPatch = ['push', 'pop', 'unshift', 'shift', 'splice', 'sort', 'reverse'];\r\n// 遍历 methodsToPatch\r\nmethodsToPatch.forEach(method => {\r\n    // 拦截数组的七个方法，先完成本职工作，再额外完成响应式的工作\r\n    Object.defineProperty(arrayMethods, method, {\r\n        value: function (...args) {\r\n            // 完成方法的本职工作，比如 this.arr.push(xx)\r\n            const ret = arrayProto[method].apply(this, args);\r\n            const ob = this.__ob__;\r\n            // 将来接着实现响应式相关的能力\r\n            console.log('array reactive');\r\n            let inserted;\r\n            switch (method) {\r\n                case 'push':\r\n                case 'unshift':\r\n                    inserted = args;\r\n                    break;\r\n                case 'splice':\r\n                    //this.arr.splice(idx, deleteNum, add args)\r\n                    inserted = args.slice(2);\r\n                    break;\r\n            }\r\n            if (inserted)\r\n                ob.observeArray(inserted);\r\n            ob.dep.notify();\r\n            return ret;\r\n        },\r\n        configurable: true,\r\n        writable: true,\r\n        enumerable: true\r\n    });\r\n});\r\n/**\r\n * 覆盖数组（arr）的原型对象\r\n * @param {*} arr\r\n */\r\nfunction protoArgument(arr) {\r\n    arr.__proto__ = arrayMethods;\r\n}\r\nexports[\"default\"] = protoArgument;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/protoArgument.ts?");

/***/ }),

/***/ "./src/proxy.ts":
/*!**********************!*\
  !*** ./src/proxy.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.proxy = void 0;\r\n/**\r\n * 将 key 代理到 target 上，\r\n * 比如 代理 this._data.xx 为 this.xx\r\n * @param {*} target 目标对象，比如 vm\r\n * @param {*} sourceKey 原始 key，比如 _data\r\n * @param {*} key 代理的原始对象上的指定属性，比如 _data.xx\r\n */\r\nfunction proxy(target, sourceKey, key) {\r\n    Object.defineProperty(target, key, {\r\n        // target.key 的读取操作实际上返回的是 target.sourceKey.key\r\n        get() {\r\n            return target[sourceKey][key];\r\n        },\r\n        // target.key 的赋值操作实际上是 target.sourceKey.key = newV\r\n        set(newV) {\r\n            target[sourceKey][key] = newV;\r\n        }\r\n    });\r\n}\r\nexports.proxy = proxy;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/proxy.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.isReserveTag = exports.isUnaryTag = void 0;\r\n/**\r\n * 是否为自闭合标签，内置一些自闭合标签，为了处理简单\r\n */\r\nfunction isUnaryTag(tagName) {\r\n    // 暂时只处理input标签\r\n    const unaryTag = ['input'];\r\n    return unaryTag.includes(tagName);\r\n}\r\nexports.isUnaryTag = isUnaryTag;\r\n/**\r\n * 判断是否为平台的保留标签\r\n */\r\nfunction isReserveTag(tagName) {\r\n    const reserveTag = [\r\n        \"div\",\r\n        \"h3\",\r\n        \"span\",\r\n        \"input\",\r\n        \"select\",\r\n        \"option\",\r\n        \"p\",\r\n        \"button\",\r\n        \"template\",\r\n    ];\r\n    return reserveTag.includes(tagName);\r\n}\r\nexports.isReserveTag = isReserveTag;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/utils.ts?");

/***/ }),

/***/ "./src/watcher.ts":
/*!************************!*\
  !*** ./src/watcher.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nconst asyncUpdateQueue_1 = __webpack_require__(/*! ./asyncUpdateQueue */ \"./src/asyncUpdateQueue.ts\");\r\nconst dep_1 = __webpack_require__(/*! ./dep */ \"./src/dep.ts\");\r\n// 用来标记 watcher\r\nlet uid = 0;\r\n/**\r\n * @param {*} cb 回调函数，负责更新 DOM 的回调函数\r\n */\r\nclass Watcher {\r\n    constructor(cb, options, vm = null) {\r\n        /**\r\n         * 响应式数据更新时，dep 通知 watcher 执行 update 方法，\r\n         * 让 update 方法执行 this._cb 函数更新 DOM\r\n         */\r\n        /**\r\n         * 响应式数据更新时，dep 通知 watcher 执行 update 方法，\r\n         * 让 update 方法执行 this._cb 函数更新 DOM\r\n         */\r\n        this.update = function () {\r\n            if (this.options.lazy) { // 懒执行，比如 computed 计算属性\r\n                // 将 dirty 置为 true，当页面重新渲染获取计算属性时就可以执行 evalute 方法获取最新的值了\r\n                this.dirty = true;\r\n            }\r\n            else {\r\n                // 将 watcher 放入异步 watcher 队列\r\n                (0, asyncUpdateQueue_1.queueWatcher)(this);\r\n            }\r\n        };\r\n        /**\r\n         * 负责执行 Watcher 的 cb 函数\r\n         * 执行时进行依赖收集\r\n         */\r\n        this.get = function () {\r\n            (0, dep_1.pushTarget)(this);\r\n            this.value = this._cb.apply(this.vm);\r\n            (0, dep_1.popTarget)();\r\n        };\r\n        this.evalute = function () {\r\n            // 执行 get，触发计算函数 (cb) 的执行\r\n            this.get();\r\n            // 将 dirty 置为 false，实现一次刷新周期内 computed 实现缓存\r\n            this.dirty = false;\r\n        };\r\n        /**\r\n       * 由刷新 watcher 队列的函数调用，负责执行 watcher.get 方法\r\n       */\r\n        this.run = function () {\r\n            this.get();\r\n        };\r\n        // 标识 watcher\r\n        this.uid = uid++;\r\n        this.options = options;\r\n        this._cb = cb;\r\n        // watcher中cb函数的执行结果\r\n        this.value = null;\r\n        // computed 计算属性实现缓存的原理，标记当前回调函数在本次渲染周期内是否已经被执行过\r\n        this.dirty = !!options.lazy;\r\n        // 绑定上下文,记录Vue实例\r\n        this.vm = vm;\r\n        // 非懒执行时，直接执行 cb 函数，cb 函数中会发生 vm.xx 的属性读取，从而进行依赖收集\r\n        !options.lazy && this.get();\r\n    }\r\n}\r\nexports[\"default\"] = Watcher;\r\n\n\n//# sourceURL=webpack://mymvvm3/./src/watcher.ts?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _myMVVM__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./myMVVM */ \"./src/myMVVM.ts\");\n/* harmony import */ var _myMVVM__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_myMVVM__WEBPACK_IMPORTED_MODULE_0__);\n\r\nconst ins = new (_myMVVM__WEBPACK_IMPORTED_MODULE_0___default())({\r\n  el: '#app',\r\n  data() {\r\n    return {\r\n      // 原始值和对象的响应式原理\r\n      name: '张三',\r\n      gender: {\r\n        female: 'beautify girl'\r\n      },\r\n      // 数组的响应式原理\r\n      arr: [{name: '吃饭'},{name: '睡觉'},{name: '打代码'}],\r\n      // 响应式更新\r\n      counter: 0,\r\n      // v-bind\r\n      title: \"看我，看我\",\r\n      // v-model\r\n      inputVal: 'hello',\r\n      isChecked: true,\r\n      selectValue: 2,\r\n    }\r\n  },\r\n  // methods + 事件 + 数据响应式更新 原理\r\n  methods: {\r\n    handleAdd() {\r\n      this.counter++\r\n    },\r\n    handleMinus() {\r\n      this.counter--\r\n    }\r\n  },\r\n  // computed + 异步更新队列 的原理\r\n  computed: {\r\n    doubleCounter() {\r\n      console.log('evalute doubleCounter')\r\n      return this.counter * 2\r\n    }\r\n  },\r\n  // 组件\r\n  components: {\r\n    // 子组件\r\n    'comp': {\r\n      template: `\r\n        <div>\r\n          <p>{{ compCounter }}</p>\r\n          <p>{{ doubleCompCounter }}</p>\r\n          <button v-on:click=\"handleCompAdd\"> comp add </button>\r\n          <button v-on:click=\"handleCompMinus\"> comp minus </button>\r\n        </div>`,\r\n      data() {\r\n        return {\r\n          compCounter: 0\r\n        }\r\n      },\r\n      methods: {\r\n        handleCompAdd() {\r\n          this.compCounter++\r\n        },\r\n        handleCompMinus() {\r\n          this.compCounter--\r\n        }\r\n      },\r\n      computed: {\r\n        doubleCompCounter() {\r\n          console.log('evalute doubleCompCounter')\r\n          return this.compCounter * 2\r\n        }\r\n      }\r\n    },\r\n    // 插槽\r\n    'scope-slot': {\r\n      template: `\r\n        <div>\r\n          <slot name=\"default\" v-bind:slotKey=\"slotKey\">{{ slotKey }}</slot>\r\n        </div>\r\n      `,\r\n      data() {\r\n        return {\r\n          slotKey: '我是插槽里面的内容'\r\n        }\r\n      }\r\n    }\r\n  }\r\n})\r\n// 数据响应式拦截\r\nsetTimeout(() => {\r\n  console.log('********** 属性值为原始值时的 getter、setter ************')\r\n  console.log(ins.name)\r\n  ins.name = '李四'\r\n  console.log(ins.name)\r\n}, 1000)\r\n\r\nsetTimeout(() => {\r\n  console.log('********** 属性的新值为对象的情况 ************')\r\n  ins.name = {\r\n    student: '张三'\r\n  }\r\n  console.log(ins.name.student)\r\n}, 2000)\r\n\r\nsetTimeout(() => {\r\n  console.log('********** 验证对深层属性的 getter、setter 拦截 ************')\r\n  ins.gender.female = 'cute girl'\r\n  console.log(ins.gender.female)\r\n}, 3000)\r\n\r\nsetTimeout(() => {\r\n  console.log('********** 将值为对象的属性更新为原始值 ************')\r\n  console.log(ins.gender)\r\n  ins.gender = 'girl'\r\n  console.log(ins.gender)\r\n}, 4000)\r\n\r\nsetTimeout(() => {\r\n  console.log('********** 数组操作方法的拦截 ************')\r\n  console.log(ins.arr)\r\n  ins.arr.push({name: '逛街'})\r\n  console.log(ins.arr)\r\n}, 5000)\n\n//# sourceURL=webpack://mymvvm3/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;